---
layout: post
title: Maven 中的 maven-shade-plugin 插件
categories: Maven
tags: Maven
date: 2020-07-12 21:00:00
description: 你知道 maven-shade-plugin 有什么作用吗？应该在什么场景使用呢？为什么 kylin-jdbc 要用 maven-shade-plugin ？？
---

# Maven 中的 maven-shade-plugin 插件

## maven-shade-plugin 插件有什么作用？

Shade 插件的作用是将一个 maven 项目打包成一个 `uber-jar`(也成为 `fat-jar`)，并且将当前项目的依赖的部分依赖也打包进去。

- 打包一个可运行的 `fat-jar`，支持指定 Main Class或者直接写入 MANIFEST.MF 文件
- 选择性的将依赖也打包到 `fat-jar` 中
    - 打包的时候自定义包含或者去除掉一些依赖
    - 打包的时候对包含的依赖进行细粒度的控制，指定包含或者排除哪些类
    - 可配置自动排除当前项目没有用到的依赖，最大程度的减小打包的 `fat-jar` 的体积
- 重命名当前项目的依赖项，将依赖项放置到重命名的文件夹中，避免依赖冲突
- 将shade 插件指定的依赖项以及当前项目打包成包含自定义标识的 `fat-jar` 的同时打包一个普通 jar 包，还能部署到 maven 仓库    
- 资源转化
- 实现 Shader 接口，自定义 shading 逻辑

### 打包一个可运行的 jar 包

`maven-shade-plugin` 插件最基础的功能就是打包出一个可执行的 `fat-jar`，主要是是对 `META-INF/MANIFEST.MF` 文件的修改

#### 为可执行的 jar 包设置 Main Class

打包一个可执行的 jar 最简单的方式就是设置 Main Class，`maven-shade-plugin` 插件提供通过`org.apache.maven.plugins.shade.resource.ManifestResourceTransformer` 设置 \<mainClass\>

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <transformers>
                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                    <mainClass>com.liam.learning.maven.plugins.demo.shade.App</mainClass>
                </transformer>
                </transformers>
            </configuration>
        </execution>
    </executions>
</plugin>
```

具体效果如下：

![](/assets/picture/shade.executable.main.class.png "Shade 指定 Main Class")

#### 向 `META-INF/MANIFEST.MF` 文件写入自定义参数

除了上面讲到了设置 Main-Class 的方式，我们还可以通过 `org.apache.maven.plugins.shade.resource.ManifestResourceTransformer` 的  \<manifestEntries\> 向 `META-INF/MANIFEST.MF` 文件写入 key-value 键值对

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <transformers>
                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                    <manifestEntries>
                    <Main-Class>com.liam.learning.maven.plugins.demo.shade.App</Main-Class>
                    <Build-Number>10086</Build-Number>
                    <Custom-Parameter>Custom Parameter</Custom-Parameter>
                    </manifestEntries>
                </transformer>
                </transformers>
            </configuration>
        </execution>
    </executions>
</plugin>
```

这里我们在 \<manifestEntries\> 中创建子节点，用子节点的名称作为 key，用子节点的值作为 value，写入 `META-INF/MANIFEST.MF` 文件，最终效果如下：

![](/assets/picture/shade.plugin.writo.custom.pair.in.mainfest.mf.png "Shade 向 MANIFEST.MF 文件写入自定义键值对")

### 打包 fat-jar 时选择放入jar 包中的依赖

`maven-shade-plugin` 插件打包的时候可以选择性的将一些依赖项也打包到 `fat-jar` 中去

#### 通过 include 或者 exclude 选择依赖放入 `fat-jar`

`maven-shade-plugin` 插件的配置中有 \<artifactSet\>，它支持设置 \<excludes\> 或者 \<includes\> 来排除或者正向选择一些依赖项打包到 `fat-jar` 中去，下面这个例子就是使用 \<includes\>

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <artifactSet>
                    <includes>
                        <include>com.google.guava:guava</include>
                    </includes>
                </artifactSet>
            </configuration>
        </execution>
    </executions>
</plugin>
```

 \<includes\> 示例实际效果如下：

![](/assets/picture/shade.plugin.artifact.set.include.png "Shade 选择加入 fat-jar 的依赖")

\<excludes\> 的使用方法和 \<includes\> 一致，需要注意的是 \<include\> 和 \<exclude\> 中的 artifact 的标识的格式是 `groupId:artifactId[[:type]:classifier]`，还有就是 \<excludes\> 的优先级高于 \<includes\> 

Shade 插件除将依赖中的class 文件写入 `fat-jar` 之外，还会在 `/META-INF/maven/` 文件夹下面写入 maven 相关文件 `pom.properties` 和 `pom.xml`，包含依赖项的 maven 坐标以及依赖项自身的依赖信息

![](/assets/picture/shade.plugin.select.dependency.write.maven.jpg "Shade 选择的依赖的 mave 信息")

这里的 `/META-INF/maven/com.google.guava/guava/pom.properties` 文件中就说明了打包进 `fat-jar` 的 guava 工具包的版本信息
```properties
#Generated by org.apache.felix.bundleplugin
#Thu Dec 26 22:08:20 EST 2019
version=28.2-jre
groupId=com.google.guava
artifactId=guava
```

#### 通过 \<filter\> 细粒度的控制依赖项的中的哪些 class 文件放入 fat-jar

有时候我们需要使用的仅仅是依赖中的部分类，为了更细粒度的控制依赖中的哪些类被放入 `fat-jar` 中，Shade 插件提供了 \<filters\> 配置节点，可以正向选择或者排除掉依赖项中的一些类，将选中的类放入 `fat-jar` 中，下面是个简单的示例

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
        <phase>package</phase>
        <goals>
            <goal>shade</goal>
        </goals>
        <configuration>
            <artifactSet>
                <includes>
                    <include>com.google.guava:guava</include>
                </includes>
            </artifactSet>
            <filters>
                <filter>
                    <artifact>com.google.guava:guava</artifact>
                    <includes>
                        <include>com/google/common/base/**</include>
                    </includes>
                </filter>
            </filters>
        </configuration>
        </execution>
    </executions>
</plugin>
```
实际效果是：

![](/assets/picture/shade.plugin.filter.select.dependency.class.png "Shade 细粒度选择放入 fat-jar 的依赖中的类")

这里将依赖 `com.google.guava:guava` 中的 `com/google/common/base/` 文件夹中的类都放入 `fat-jar` 中，这里需要注意注意一下，这时候 `/META-INF/maven/` 文件夹中没有 `com.google.guava:guava` 依赖的 maven 信息，没有办法直观的确定依赖项的版本信息了。


#### 使用 \<minimizeJar\>true\</minimizeJar\> 将最小范围内的依赖打包进 fat-jar

除了上面讲到的手动的选择依赖放入 `fat-jar`，Shade 插件还支持自动删除依赖中没有用到的类，再将剩下的类放入 `fat-jar` 中，尽量打包一个体积最小的 `fat-jar`

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <minimizeJar>true</minimizeJar>
            </configuration>
        </execution>
    </executions>
</plugin>
```

执行 mvn 指令时，加上 `-X` 参数，在 DEBUG 日志中可以看到 Shade 插件会删除没有使用的类

![](/assets/picture/shade.plugin.minimize.jar.remove.class.jpg "Shade 删除不使用的类，精简 fat-jar")

#### \<minimizeJar\> 和 \<filter\> 的结合使用

Shade 插件在 1.6 及其以上版本中， \<minimizeJar\> 和包含过滤器(\<filter\> 和 \<includes\>) 结合使用，可以对过滤器正向选择的依赖隐式去除不使用的依赖，但是如果使用过了 `<excludeDefaults>fasle</excludeDefaults>` 则上述行为将不会发生

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <minimizeJar>true</minimizeJar>
                <filters>
                    <filter>
                    <artifact>com.google.guava:guava</artifact>
                    <excludeDefaults>false</excludeDefaults>
                        <includes>
                            <include>com/google/common/base/Preconditions.class</include>
                            <include>com/google/common/annotations/Beta.class</include>
                            <include>com/google/common/annotations/GwtCompatible.class</include>
                            <include>com/google/errorprone/annotations/CanIgnoreReturnValue.class</include>
                        </includes>
                    </filter>
                </filters>
            </configuration>
        </execution>
    </executions>
</plugin>
```

#### 对依赖项的权限名进行重命名，避免依赖冲突

JVM 通过类加载器去加载类，类加载器通过类的全限定名去确定一个类，Shade 插件支持将依赖项中的类的全限定名进行重命名，当前项目中的 import 语句也会被修改

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <relocations>
                    <relocation>
                        <pattern>com.google</pattern>
                        <shadedPattern>com.google.shade</shadedPattern>
                    </relocation>
                </relocations>
            </configuration>
        </execution>
    </executions>
</plugin>
```

这里我们将 `com.google` 重命名为 `com.google.shade`，Shade 插件在打包的时候，会将 com.google.* 下的类的全限定名改为 com.google.shade，还会将使用到 com.google.* 的 import 语句中的全限定名进行修改，效果如下：

![](/assets/picture/shade.plugin.relocation.dependencies.result.jpg "Shade 插件重命名依赖项")

#### 同时打包 shade 包和普通 jar 包

默认情况下使用 Shade 插件打包会用插件修改后的 jar 包去替换支持情况下的普通包，并且能把这个jar 包部署到 maven 仓库；Shade 插件也支持同时打包、部署插件修改的 jar 包和普通的 jar 包，这就需要使用 `<shadedArtifactAttached>true</shadedArtifactAttached>` 配置。

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <shadedArtifactAttached>true</shadedArtifactAttached>
                <shadedClassifierName>with-shade-classifier</shadedClassifierName> <!-- Any name that makes sense -->
            </configuration>
        </execution>
    </executions>
</plugin>
```
![](/assets/picture/shade.plugin.package.shade.and.common.jar.jpg "Shade 插件同时打包 shade 包和普通jar 包")

#### 资源转换器

这一部分了解不多，目前没有用到过，有时间再补充，详细信息参见[官方文档](http://maven.apache.org/plugins/maven-shade-plugin/examples/resource-transformers.html#)

#### 自定义 Shade 插件的功能

Shade 插件定义了一个接口 `org.apache.maven.plugins.shade.Shader`，它的默认实现是 `org.apache.maven.plugins.shade.DefaultShader`；Shade 插件还支持自行实现 `Shader` 接口，自定义Shade 插件的功能，具体步骤如下

##### 实现一个自定义功能的 Shade 插件的扩展项目

首先是创建一个自定义的 Shade 插件扩展项目，然后在按照以下步骤完成扩展项目的开发

- 引入依赖包 

```xml
<dependency>
    <groupId>org.codehaus.plexus</groupId>
    <artifactId>plexus-component-annotations</artifactId>
    <version>2.1.0</version>
</dependency>
```

- 实现自己的 Shader 

```java
@Component( role = Shader.class, hint = "mock" )
public class MockShader
    implements Shader
{
  // implement the interface here
}
```

- 在扩展项目中加入 plexus-component-metadata 插件

`org.codehaus.plexus:plexus-component-metadata` 插件的作用是生成 `META-INF/plexus/components.xml` 文件去描述组件信息

```xml
<plugin>
    <groupId>org.codehaus.plexus</groupId>
    <artifactId>plexus-component-metadata</artifactId>
    <version>1.5.5</version>
    <executions>
        <execution>
            <goals>
                <goal>generate-metadata</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

##### 使用自定义的 Shader 实现

```xml
<project>
  ...
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>3.2.4</version>
        <dependencies>
          <dependency>
            <groupId>org.your.custom.shade</groupId>
            <artifactId>mock-shader</artifactId>
            <version>1.0</version>
          </dependency>
        </dependencies>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>shade</goal>
            </goals>
            <configuration>
              <shaderHint>mock</shaderHint> // 在 MockShader 中设置的 hint
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
  ...
</project>
```

## maven-shade-plugin 的参数说明

`maven-shade-plugin` 的目标只有两个， `shade:help` 和 `shade:shade`，这里讲解一下 `shade:shade` 相关的参数

### \<artifactSet\>

- 参数说明：指定 `fat-jar` 中包含或者排除哪些依赖，通过 `groupId:artifactId:type:classifier` 这种复合标识符来标识，从 1.3 版本开始复合标识符支持 `*` 和 `?`，为了便利的使用
    - `groupId` 等同于 `groupId:*:*:*`
    - `groupId:artifactId` 等同于 `groupId:artifactId:*:*`
    - `groupId:artifactId:classifier` 等同于 `groupId:artifactId:*:classifier`
- 使用示例：
```xml
<artifactSet>
    <includes>
        <include>com.google.guava</include>
    </includes>
    <excludes>
        <exclude>*:commons-logging</exclude>
    </excludes>
</artifactSet>
```
- 是否必填：否

### \<createDependencyReducedPom\>	

- 参数说明：控制是否精简 `fat-jar` 中 `pom.xml` 文件的参数，默认值为 true，包含在 `fat-jar` 中的依赖将被从 `pom.xml` 文件的 `<dependencies>` 节点下被删除，避免了使用 `fat-jar` 的项目中出现不必要的依赖冲突；被精简的 `pom.xml` 文件被命名为 `dependency-reduced-pom.xml`，存储在 `pom.xml` 所在目录中，除非你用 \<dependencyReducedPomLocation\> 参数指定 `dependency-reduced-pom.xml` 文件的存储位置
- 是否必填：否
- 默认值：true

### \<<createSourcesJar\>

- 参数说明：控制是否的打包源文件 jar 包的参数
- 参数类型：boolean
- 是否必填：否

### \<<createSourcesJar\>

- 参数说明：控制是否的打包测试源代码 jar 包的参数
- 参数类型：boolean
- 是否必填：否

### \<dependencyReducedPomLocation\>

- 参数说明：指定 `dependency-reduced-pom.xml` 文件的存储位置
- 参数类型：java.io.File
- 是否必填：否
- 默认值：${basedir}/dependency-reduced-pom.xml

### \<filters\>

- 参数说明：归档打包 `fat-jar` 的时候用到的过滤器，支持使用和 `<artifactSet>` 标签中格式一样的复合标识符标识一个依赖，再指定一组 `include`/`exclude` 文件表达式，去过滤选择加入 `fat-jar` 包的文件；`<include>` 节点先被处理，`<exclude>` 后被处理，所以 `<exclude>` 排除过滤器优先级更高，先用包含过滤器选择一批文件，再用排除过滤器去除掉一部分文件，剩下的再放入 `fat-jar` 包；默认情况下所有的依赖文件都会被归档，指定了多个包含和排除过滤器的时候，选择多个过滤器的交集放入 `fat-jar` 中。
- 使用示例：
```xml
<filters>
  <filter>
    <artifact>junit:junit</artifact>
    <includes>
      <include>org/junit/**</include>
    </includes>
    <excludes>
      <exclude>org/junit/experimental/**</exclude>
    </excludes>
  </filter>
</filters>
```
- 是否必填：否

### \<finalName\>

- 参数说明：`fat-jar` 的名称，通过 `<build><finalName>` 可以自定义jar 包名称，Shade 插件的 `<finalName>` 如果和 `<build><finalName>` 设置的不一致，部署到 maven 仓库的jar 包只会是普通的jar，Shade 插件不会进行任何替换操作，即使设置了 `shadedArtifactAttached` 参数
- 是否必填：否

### \<generateUniqueDependencyReducedPom\>

- 参数说明：创建 `dependency-reduced-pom.xml` 时，是否在文件名中增加唯一标识，如果为 true，则创建的文件名称为 `dependency-reduced-pom-[UniqueKey].xml`，避免多次构建中创建的 `dependency-reduced-pom.xml` 被覆盖
- 参数类型：boolean
- 是否必填：否
- 默认值：false

### \<keepDependenciesWithProvidedScope\>

- 参数说明：和 createDependencyReducedPom 参数不一样，keepDependenciesWithProvidedScope 参数为 true 时 `pom.xml` 中的依赖项不会被删除，会被保留，但是 `<scope>` 是 `provided`， 也就是说项目的依赖项需要实际项目所在的容器提供。***这也意味着使用这个参数的时候不要对依赖项进行重命名了，否则会出现依赖缺失***
- 参数类型：boolean
- 是否必填：否
- 默认值：false
- 使用示例：
```xml
<plugin>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <keepDependenciesWithProvidedScope>true</keepDependenciesWithProvidedScope>
            </configuration>
        </execution>
    </executions>
</plugin>
```

- 示例效果

![](/assets/picture/shade.plugin.keep.dependencies.with.provided.scope.jpg "Shade 插件保留依赖项，设置为 provided 作用域")

### \<minimizeJar\>

- 参数说明：是否自动精简依赖项中的文件，当前项目中没有使用的类文件被自动删除，不会被加入 `fat-jar`
- 参数类型：boolean
- 是否必填：否
- 默认值：false 

***未完待续***

## maven-shade-plugin 的使用场景是什么？ 

从上面讲到的 Shade 插件的功能来看，它的作用主要是

- 打包一个可以执行 jar 包
- 选择项目依赖也打包到 `fat-jar` 中
- 重命名依赖项中 Class 的全限定名，对使用依赖的的 import 语句也进行修改，避免依赖冲突

前两个功能的使用都比较简单，从上面即可看到如何使用，下面主要讲讲 ***如何使用 Shade 插件解决依赖同一个jar 包的不同版本***

### 如何使用 Shade 插件解决依赖同一个jar 包的不同版本

实际项目中可能会出现这种情况，我们的业务项目 `com.liam:biz` 依赖 `com.xxx:dep1:1.0` 和 `com.xxx:dep2:1.0`，`com.xxx:dep1:1.0` 传递依赖 `com.xxx:dep3:1.1`，而 `com.xxx:dep2:1.0` 依赖 `com.xxx:dep3:1.2`，这里就出现了对 `com.xxx:dep3` 两个版本的依赖，如果 `com.xxx:dep3` 高版本对低版本进行了向下兼容，你可以直接在 \<dependencyManagement\> 中指定使用高版本的 `com.xxx:dep3:1.2`，但是如果 `com.xxx:dep3:1.3` 和 `com.xxx:dep3:1.2` 不兼容呢？

![](/assets/picture/biz.use.same.dependency.with.multi.version.png "业务项目中使用到同一个 jar 包的不同版本")

看到这个问题，我们考虑对三方包 `com.xxx:dep3` 进行一些修改，修改成一个自定义的二方包，修改 依赖的类的全限定名，这里我们就可以使用 Shade 插件的 \<relocations\>，将依赖项打包进 `fat-jar` 的同时，对依赖的类的全限定名进行修改，就可以避免依赖冲突了，具体插件配置如下:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <relocations>
                    <relocation>
                        <pattern>com.xxx.dep3</pattern>
                        <shadedPattern>shaded.com.xxx.dep3</shadedPattern>
                    </relocation>
                </relocations>
            </configuration>
        </execution>
    </executions>
</plugin>
```

这样 `fat-jar` 中就会包含 `/shaded/com.xxx.dep3/**` 为路径的依赖，业务代码中的 import 语句也会被修改为 `import shaded.com.xxx.dep3.xxx` 